type Collection = record {
  collection_fee : nat;
  creation_time : nat64;
  nft_canister_standard : NFTStandard;
  owner : principal;
  collection_name : text;
  fungible_volume : nat;
  fungible_canister_standard : FungibleStandard;
  fungible_canister_id : principal;
  nft_canister_id : principal;
};
type FungibleStandard = variant { DIP20 };
type GenericValue = variant {
  Nat64Content : nat64;
  Nat32Content : nat32;
  BoolContent : bool;
  Nat8Content : nat8;
  Int64Content : int64;
  IntContent : int;
  NatContent : nat;
  Nat16Content : nat16;
  Int32Content : int32;
  Int8Content : int8;
  FloatContent : float64;
  Int16Content : int16;
  BlobContent : vec nat8;
  NestedContent : Vec;
  Principal : principal;
  TextContent : text;
};
type Listing = record {
  fee : vec record { text; principal; nat };
  status : ListingStatus;
  created : nat64;
  seller : principal;
  price : nat;
};
type ListingStatus = variant { Selling; Uninitialized; Created };
type MPApiError = variant {
  NonExistentCollection;
  NoDeposit;
  InvalidListingStatus;
  InsufficientFungibleBalance;
  InvalidListing;
  TransferNonFungibleError;
  Unauthorized;
  InsufficientFungibleAllowance;
  TransferFungibleError;
  InvalidOffer;
  InvalidOwner;
  Other : text;
  InsufficientNonFungibleBalance;
  InvalidOfferStatus;
  InvalidOperator;
  CAPInsertionError;
};
type NFTStandard = variant { EXT; DIP721v2 };
type Offer = record {
  status : OfferStatus;
  created : nat64;
  token_id : nat;
  token_owner : principal;
  buyer : principal;
  price : nat;
  nft_canister_id : principal;
};
type OfferStatus = variant {
  Bought;
  Uninitialized;
  Denied;
  Cancelled;
  Created;
};
type Result = variant { Ok; Err : MPApiError };
type Result_1 = variant { Ok : nat; Err : MPApiError };
type Result_2 = variant { Ok : Listing; Err : MPApiError };
type Result_3 = variant { Ok : TokenMetadata; Err : MPApiError };
type TokenMetadata = record {
  transferred_at : opt nat64;
  transferred_by : opt principal;
  owner : opt principal;
  operator : opt principal;
  approved_at : opt nat64;
  approved_by : opt principal;
  properties : vec record { text; GenericValue };
  is_burned : bool;
  token_identifier : nat;
  burned_at : opt nat64;
  burned_by : opt principal;
  minted_at : nat64;
  minted_by : principal;
};
type Vec = vec record {
  text;
  variant {
    Nat64Content : nat64;
    Nat32Content : nat32;
    BoolContent : bool;
    Nat8Content : nat8;
    Int64Content : int64;
    IntContent : int;
    NatContent : nat;
    Nat16Content : nat16;
    Int32Content : int32;
    Int8Content : int8;
    FloatContent : float64;
    Int16Content : int16;
    BlobContent : vec nat8;
    NestedContent : Vec;
    Principal : principal;
    TextContent : text;
  };
};
service : (principal, nat, opt principal) -> {
  acceptOffer : (principal, nat, principal) -> (Result);
  addCollection : (
      principal,
      nat,
      nat64,
      text,
      principal,
      NFTStandard,
      principal,
      FungibleStandard,
    ) -> (Result);
  balanceOf : (principal) -> (vec record { principal; nat }) query;
  cancelListing : (principal, nat) -> (Result);
  cancelOffer : (principal, nat) -> (Result);
  denyOffer : (principal, nat, principal) -> (Result);
  dfxInfo : () -> (text) query;
  directBuy : (principal, nat) -> (Result);
  getAllBalances : () -> (
      vec record { record { principal; principal }; nat },
    ) query;
  getBuyerOffers : (principal, principal) -> (vec Offer) query;
  getCollections : () -> (vec record { principal; Collection }) query;
  getFloor : (principal) -> (Result_1) query;
  getProtocolFee : () -> (nat) query;
  getTokenListing : (principal, nat) -> (Result_2) query;
  getTokenOffers : (principal, vec nat) -> (
      vec record { nat; vec Offer },
    ) query;
  gitCommitHash : () -> (text) query;
  makeListing : (principal, nat, nat) -> (Result);
  makeOffer : (principal, nat, nat) -> (Result);
  rustToolchainInfo : () -> (text) query;
  setProtocolFee : (nat) -> (Result);
  test : (principal, nat) -> (Result_3);
  withdrawFungible : (principal, FungibleStandard) -> (Result);
}