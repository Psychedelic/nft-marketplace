type FungibleStandard = variant { DIP20 };
type Listing = record {
  status : ListingStatus;
  is_direct_buyable : bool;
  price : nat;
  payment_address : principal;
};
type ListingStatus = variant { Selling; Uninitialized; Created };
type MPApiError = variant {
  NonExistentCollection;
  InvalidListingStatus;
  InsufficientFungibleBalance;
  InvalidListing;
  TransferNonFungibleError;
  Unauthorized;
  TransferFungibleError;
  InvalidOffer;
  Other : text;
  InsufficientNonFungibleBalance;
  InvalidOfferStatus;
  CAPInsertionError;
};
type NFTStandard = variant { EXT; DIP721 };
type Offer = record {
  status : OfferStatus;
  token_id : nat64;
  price : nat;
  payment_address : principal;
  nft_canister_id : principal;
};
type OfferStatus = variant {
  Bought;
  Uninitialized;
  Denied;
  Cancelled;
  Created;
};
type Result = variant { Ok; Err : MPApiError };
type Result_1 = variant { Ok : nat64; Err : MPApiError };
service : (principal, principal) -> {
  acceptOffer : (nat64) -> (Result);
  addCollection : (
      principal,
      nat16,
      nat64,
      text,
      principal,
      NFTStandard,
      principal,
      FungibleStandard,
    ) -> ();
  cancelListing : (principal, nat64) -> (Result);
  cancelOfferByBuyer : (nat64) -> (Result);
  denyOffer : (nat64) -> (Result);
  directBuy : (principal, nat64) -> (Result);
  getAllListings : () -> (
      vec record { record { principal; nat64 }; Listing },
    ) query;
  getAllOffers : (nat64, nat64) -> (vec Offer) query;
  makeListing : (bool, principal, nat64, nat) -> (Result);
  makeOffer : (principal, nat64, nat) -> (Result_1);
  withdrawFungible : (principal, FungibleStandard) -> (Result);
}