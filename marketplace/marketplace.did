
/// BEGIN DIP20 ///
type TxError = variant {
  InsufficientAllowance;
  InsufficientBalance;
  ErrorOperationStyle;
  Unauthorized;
  LedgerTrap;
  ErrorTo;
  Other;
  BlockUsed;
  AmountTooSmall;
};
/// END DIP20 ///

/// BEGIN DIP721 ///

 type ApiError =
 variant {
   Unauthorized;
   InvalidTokenId;
   ZeroAddress;
   Other;
 };

 type OwnerResult =
 variant {
   Err: ApiError;
   Ok: principal;
 };

 type TxReceipt =
 variant {
   Err: ApiError;
   Ok: nat;
 };

 type InterfaceId =
 variant {
   Approval;
   TransactionHistory;
   Mint;
   Burn;
   TransferNotification;
 };

 type LogoResult =
 record {
   logo_type: text; // MIME type of the logo
   data: text; // Base64 encoded logo
 };

 type ExtendedMetadataResult =
 record {
     metadata_desc: MetadataDesc;
     token_id: nat64;
 };

 type MetadataResult =
 variant {
   Err: ApiError;
   Ok: MetadataDesc;
 };

 type MetadataDesc = vec MetadataPart;

 type MetadataPart = record {
   purpose: MetadataPurpose;
   key_val_data: vec MetadataKeyVal;
   data: blob;
 };

 type MetadataPurpose =
 variant {
     Preview; // used as a preview, can be used as preivew in a wallet
     Rendered; // used as a detailed version of the NFT
 };

 type MetadataKeyVal =
 record {
     key: text;
     val: MetadataVal;
 };

 type MetadataVal =
 variant {
    TextContent : text;
    BlobContent : blob;
    NatContent : nat;
    Nat8Content: nat8;
    Nat16Content: nat16;
    Nat32Content: nat32;
    Nat64Content: nat64;
  };

 type TransactionResult =
 record {
     fee: nat;
     transaction_type: TransactionType;
 };

 type TransactionType =
 variant {
      Transfer:
      record {
        token_id: nat64;
        from: principal;
        to: principal;
     };
     TransferFrom:
      record {
          token_id: nat64;
          from: principal;
          to: principal;
      };
      Approve:
       record {
          token_id: nat64;
          from: principal;
          to: principal;
       };
      SetApprovalForAll:
       record {
          from: principal;
          to: principal;
       };
      Mint:
       record {
          token_id: nat64;
          to: principal;
       };
      Burn:
       record {
          token_id: nat64;
       };
 };

 type MintReceipt =
 variant {
   Err: ApiError;
   Ok: MintReceiptPart;
 };

 type MintReceiptPart =
 record {
   token_id: nat64; // minted token id
   id: nat; // transaction id
  };

// END DIP721 //


type BuyOffer = record {
  status : BuyOfferStatus;
  non_fungible_contract_address : principal;
  token_id : text;
  price : nat;
  payment_address : principal;
};
type BuyOfferStatus = variant {
  Bought;
  CancelledByBuyer;
  Uninitialized;
  Created;
  CancelledBySeller;
};
type FungibleTokenType = variant { DIP20 };
type MPApiError = variant {
  NonExistentCollection;
  InvalidSaleOfferStatus;
  InsufficientFungibleBalance;
  InvalidSaleOffer;
  InvalidBuyOfferStatus;
  TransferNonFungibleError;
  Unauthorized;
  TransferFungibleError;
  InvalidBuyOffer;
  Other;
  InsufficientNonFungibleBalance;
  CAPInsertionError;
};
type NonFungibleTokenType = variant { EXT; DIP721 };
type Result = variant { Ok; Err : MPApiError };
type Result_1 = variant { Ok : nat64; Err : MPApiError };
type SaleOffer = record {
  status : SaleOfferStatus;
  is_direct_buyable : bool;
  payment_address : principal;
  list_price : nat;
};
type SaleOfferStatus = variant { Selling; Uninitialized; Created };
service : (principal, principal) -> {
  acceptBuyOffer : (nat64) -> (Result);
  addCollection : (
      principal,
      nat16,
      nat64,
      text,
      principal,
      NonFungibleTokenType,
      principal,
      FungibleTokenType,
    ) -> ();
  cancelListingBySeller : (principal, text) -> (Result);
  cancelOfferByBuyer : (nat64) -> (Result);
  cancelOfferBySeller : (nat64) -> (Result);
  getBuyOffers : (nat64, nat64) -> (vec BuyOffer) query;
  getSaleOffers : () -> (
      vec record { record { principal; text }; SaleOffer },
    ) query;
  listForSale : (principal, text, nat) -> (Result);
  directBuy : (principal, text) -> (Result);
  makeBuyOffer : (principal, text, nat) -> (Result_1);
  withdrawFungible : (principal, FungibleTokenType) -> (Result);
}
